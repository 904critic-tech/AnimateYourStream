import { useRef, useState, useEffect, useCallback } from 'react'
import { useFrame, useThree } from '@react-three/fiber'
import { Group, Mesh, AnimationMixer, AnimationClip, Box3, Vector3, Bone, Skeleton, SkinnedMesh, SkeletonHelper, Object3D, Sphere, SphereGeometry, MeshBasicMaterial, Uint16BufferAttribute, Float32BufferAttribute, PerspectiveCamera, Raycaster, Vector2, QuaternionKeyframeTrack, Quaternion, Euler } from 'three'
import { FBXLoader, GLTFLoader, GLTFExporter, DRACOLoader, KTX2Loader } from 'three-stdlib'
import { buildNameMapping, retargetClipsByName } from './Retargeting'
import { createSafeLoader, withFetchContextFix } from '../utils/fetchContextFix'
import { useAppStore } from '../utils/store'
import AnimationController from './AnimationController'
import LipSync from './LipSync'
import type { FacialRig } from '../lipSync/types'

interface Marker {
  name: string
  position: Vector3
  mesh: Mesh
}

interface SandboxModelViewerProps {
  onModelLoaded?: (model: Group, animations: AnimationClip[], mixer: AnimationMixer | null) => void
}

export default function SandboxModelViewer({ onModelLoaded }: SandboxModelViewerProps) {
  const groupRef = useRef<Group>(null!)
  const { scene, camera, gl } = useThree()
  const loadIdRef = useRef(0)
  const lastLoadedUrlRef = useRef<string | null>(null)
  
  // State management
  const [currentRoot, setCurrentRoot] = useState<Group | null>(null)
  const [markers, setMarkers] = useState<Marker[]>([])
  const [skeletonHelper, setSkeletonHelper] = useState<SkeletonHelper | null>(null)
  const [isSkeletonVisible, setIsSkeletonVisible] = useState<boolean>(true)
  // Note: retained for future rig features
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const [skeletonRoot, setSkeletonRoot] = useState<Object3D | null>(null)
  const [currentSkeleton, setCurrentSkeleton] = useState<Skeleton | null>(null)
  const [mixer, setMixer] = useState<AnimationMixer | null>(null)
  const [currentAnimations, setCurrentAnimations] = useState<AnimationClip[]>([])
  // Note: retained for camera framing and potential UI scale indicators
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const [currentModelRadius, setCurrentModelRadius] = useState(1)
  const [guidedLabels, setGuidedLabels] = useState<string[] | null>(null)
  const [guidedIndex, setGuidedIndex] = useState(0)
  const [placing, setPlacing] = useState(false)
  
  const { currentModel, currentUploadedModel, clearUploadedModels, setCurrentUploadedModel, lipSyncEnabled } = useAppStore()
  const applyDefaultAnimationSelection = useCallback((clips: AnimationClip[]) => {
    try {
      const { currentModel: cm, lastSelectedAnimationByModel, setCurrentAnimation, setIsPlaying } = useAppStore.getState()
      const names = (clips || []).map(c => c.name)
      if (names.length === 0) return
      const preferred = cm ? lastSelectedAnimationByModel[cm] : undefined
      const pick = (preferred && names.includes(preferred)) ? preferred : names[0]
      setCurrentAnimation(pick)
      setIsPlaying(true)
    } catch {}
  }, [])
  // Auto-detected animation library via manifest (generated by scripts/generate_animation_manifest.cjs)
  const [externalAnimationLibrary, setExternalAnimationLibrary] = useState<Record<string, Array<{ name: string; path: string }>>>({})
  useEffect(() => {
    fetch('/Default_Characters/animation_manifest.json', { cache: 'no-store' })
      .then(res => res.ok ? res.json() : null)
      .then((json) => {
        if (json && json.models) setExternalAnimationLibrary(json.models)
      })
      .catch(() => {})
  }, [])

  // ðŸŽ­ Agent 4 - Fix: Clear any uploaded models that might interfere with character loading
  useEffect(() => {
    // Clear any uploaded models to ensure proper character loading for lip sync testing
    if (currentUploadedModel) {
      console.log('ðŸŽ­ Agent 4 - Clearing uploaded model to ensure proper character loading:', currentUploadedModel.name)
      clearUploadedModels()
      setCurrentUploadedModel(null)
    }
    
    // Ensure we have a proper character for lip sync testing
    if (!currentModel) {
      console.log('ðŸŽ­ Agent 4 - No current model set, defaulting to Elmo for lip sync testing')
      // The store should already default to 'elmo', but let's make sure
    } else {
      console.log('ðŸŽ­ Agent 4 - Current model for lip sync testing:', currentModel)
    }
  }, []) // Run only once on mount
  
  // Loader instances
  const fbxLoader = useRef<FBXLoader | null>(null)
  const gltfLoader = useRef<GLTFLoader | null>(null)
  const gltfExporter = useRef<GLTFExporter | null>(null)
  const raycasterRef = useRef<Raycaster | null>(null)
  const pointerNdcRef = useRef<Vector2>(new Vector2())
  const guidedOverlayRef = useRef<HTMLDivElement | null>(null)
  
  // Initialize loaders
  useEffect(() => {
    fbxLoader.current = new FBXLoader()
    gltfLoader.current = new GLTFLoader()
    try {
      // Configure DRACO and KTX2 decoders to mirror sandbox capabilities
      const draco = new DRACOLoader()
      draco.setDecoderPath('/legacy/vendor/examples/jsm/libs/draco/')
      gltfLoader.current.setDRACOLoader(draco)
      const ktx2 = new KTX2Loader()
      ktx2.setTranscoderPath('/legacy/vendor/examples/jsm/libs/basis/')
      try { (ktx2 as any).detectSupport(gl) } catch {}
      gltfLoader.current.setKTX2Loader(ktx2)
    } catch {}
    // Optional Meshopt decoder for GLB with Meshopt compression
    (async () => {
      try {
        const mod: any = await import('three/examples/jsm/libs/meshopt_decoder.module.js')
        const meshopt = mod?.MeshoptDecoder || mod?.default || mod || null
        if (meshopt && gltfLoader.current && (gltfLoader.current as any).setMeshoptDecoder) {
          (gltfLoader.current as any).setMeshoptDecoder(meshopt)
        }
      } catch {}
    })()
    gltfExporter.current = new GLTFExporter()
    raycasterRef.current = new Raycaster()
  }, [gl])
  
  // Frame object to fit camera
  const frameObject = useCallback((object3d: Object3D) => {
    try {
      const box = new Box3().setFromObject(object3d)
      if (box.isEmpty()) return
      
      const center = new Vector3()
      const sphere = new Sphere()
      box.getCenter(center)
      box.getBoundingSphere(sphere)
      setCurrentModelRadius(sphere.radius || 1)
      
      // Recenter object around origin
      object3d.position.sub(center)
      
      const persp = camera as PerspectiveCamera
      const fov = (persp && typeof (persp as any).fov === 'number' ? persp.fov : 60) * Math.PI / 180
      let distance = sphere.radius / Math.tan(fov * 0.5)
      if (!isFinite(distance) || distance <= 0) distance = 3
      // Pull camera back for a more comfortable default view
      distance = Math.max(distance * 2.5, sphere.radius * 3.0)
      
      persp.position.set(0, sphere.radius * 0.5, distance)
      persp.lookAt(0, 0, 0)
    } catch (e) {
      console.error('Frame object failed:', e)
    }
  }, [camera])
  
  // Load model function
  const disposeObject3D = (obj: Object3D) => {
    try {
      obj.traverse((child: any) => {
        if (child.isMesh) {
          if (child.geometry) {
            child.geometry.dispose?.()
          }
          const disposeMaterial = (mat: any) => {
            if (!mat) return
            if (mat.map) mat.map.dispose?.()
            if (mat.normalMap) mat.normalMap.dispose?.()
            if (mat.metalnessMap) mat.metalnessMap.dispose?.()
            if (mat.roughnessMap) mat.roughnessMap.dispose?.()
            if (mat.emissiveMap) mat.emissiveMap.dispose?.()
            if (mat.aoMap) mat.aoMap.dispose?.()
            mat.dispose?.()
          }
          if (Array.isArray(child.material)) child.material.forEach(disposeMaterial)
          else disposeMaterial(child.material)
        }
      })
    } catch {}
  }

  // Generate a lightweight procedural idle animation when no clips exist
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const createProceduralIdleClip = useCallback((root: Object3D): AnimationClip => {
    const { currentModel, proceduralIdleSettings } = useAppStore.getState()
    const settings = (currentModel && proceduralIdleSettings[currentModel]) || { enabled: true, amplitude: 0.03, speed: 1.25 }
    const speed = Math.max(0.25, Math.min(3.0, settings.speed ?? 1.25))
    const duration = 2 / speed

    // Four-point cycle for smooth sway (yaw +/- and subtle roll)
    const times = [0, duration / 3, (2 * duration) / 3, duration]
    const e0 = new Euler(0, -2 * Math.PI / 180, -1 * Math.PI / 180)
    const e1 = new Euler(0, 0, 0)
    const e2 = new Euler(0, 2 * Math.PI / 180, 1 * Math.PI / 180)
    const e3 = new Euler(0, 0, 0)
    const q0 = new Quaternion().setFromEuler(e0)
    const q1 = new Quaternion().setFromEuler(e1)
    const q2 = new Quaternion().setFromEuler(e2)
    const q3 = new Quaternion().setFromEuler(e3)
    const quatValues = [
      q0.x, q0.y, q0.z, q0.w,
      q1.x, q1.y, q1.z, q1.w,
      q2.x, q2.y, q2.z, q2.w,
      q3.x, q3.y, q3.z, q3.w
    ]
    const rotTrack = new QuaternionKeyframeTrack('.quaternion', times, quatValues)
    // Remove vertical bounce to avoid twitching
    return new AnimationClip('procedural_idle', duration, [rotTrack])
  }, [])

  const loadModel = useCallback(async (url: string, name?: string) => {
    try {
      // Avoid reloading identical URL rapidly
      if (lastLoadedUrlRef.current === url) {
        console.log('ðŸŽ­ Sandbox: Skipping duplicate load for URL')
        return
      }
      lastLoadedUrlRef.current = url
      const myLoadId = ++loadIdRef.current
      console.log('ðŸŽ­ Sandbox: Loading model:', url)
      
      // Reset per-load fallback guard
      try { (window as any).__ANIM_FALLBACK_TRIED__ = false } catch {}

      // Stop previous mixer actions if present
      try {
        if (mixer) mixer.stopAllAction()
      } catch {}

      // Proactively remove any previous sandbox-tagged roots to avoid overlaps
      try {
        const toRemove: Object3D[] = []
        scene.traverse((obj: any) => {
          if (obj && obj.__SANDBOX_MODEL_ROOT__) toRemove.push(obj)
        })
        toRemove.forEach(obj => {
          disposeObject3D(obj)
          scene.remove(obj)
        })
      } catch {}

      // Clear existing model tracked by state
      if (currentRoot) {
        disposeObject3D(currentRoot)
        scene.remove(currentRoot)
        setCurrentRoot(null)
      }

      // Also clear markers and skeleton helper when switching models
      try {
        markers.forEach(marker => scene.remove(marker.mesh))
        setMarkers([])
        if (skeletonHelper) {
          scene.remove(skeletonHelper)
          setSkeletonHelper(null)
        }
        setSkeletonRoot(null)
        setCurrentSkeleton(null)
      } catch {}
      
      // Detect file format safely
      const knownExts = ['fbx', 'glb', 'gltf']
      const extFromNameMatch = name && /\.([a-zA-Z0-9]+)$/.exec(name)
      const extFromName = extFromNameMatch ? extFromNameMatch[1].toLowerCase() : undefined
      const extFromUrl = (() => {
        const clean = url.split('?')[0]
        const idx = clean.lastIndexOf('.')
        return idx !== -1 ? clean.substring(idx + 1).toLowerCase() : undefined
      })()
      let extension = knownExts.includes(extFromName || '') ? extFromName : extFromUrl
      if ((!extension || extension === url) && url.startsWith('blob:')) {
        // Default to glb for blob URLs when no name provided
        extension = 'glb'
      }
      let model: Group
      
      if (extension === 'fbx' && fbxLoader.current) {
        model = await new Promise<Group>((resolve, reject) => {
          fbxLoader.current!.load(
            url,
            (g) => resolve(g),
            undefined,
            (err) => {
              console.error('ðŸŽ­ Sandbox: FBX load failed:', (err && (err as any).message) || String(err))
              reject(err)
            }
          )
        })
      } else if ((extension === 'glb' || extension === 'gltf') && gltfLoader.current) {
        // Safe GLTF loader with fetch-context fix to prevent Illegal invocation on blob URLs
        const loader: any = createSafeLoader(GLTFLoader)()
        try {
          const draco = new DRACOLoader()
          draco.setDecoderPath('/legacy/vendor/examples/jsm/libs/draco/')
          loader.setDRACOLoader?.(draco)
          const ktx2 = new KTX2Loader()
          ktx2.setTranscoderPath('/legacy/vendor/examples/jsm/libs/basis/')
          try { (ktx2 as any).detectSupport?.(gl) } catch {}
          loader.setKTX2Loader?.(ktx2)
          try {
            const mod: any = await import('three/examples/jsm/libs/meshopt_decoder.module.js')
            const meshopt = mod?.MeshoptDecoder || mod?.default || mod || null
            if (meshopt) loader.setMeshoptDecoder?.(meshopt)
          } catch {}
        } catch {}
        try {
          let result: any
          if (url.startsWith('blob:')) {
            if (extension === 'gltf') {
              // .gltf with external buffers/textures cannot be resolved from a single file upload
              throw new Error('GLTF with external resources is not supported from a single-file upload. Please upload a GLB.')
            }
            // Bypass fetch entirely: use XHR to read blob URL as ArrayBuffer, then parse
            const buffer: ArrayBuffer = await new Promise((resolve, reject) => {
              const req = new XMLHttpRequest()
              req.responseType = 'arraybuffer'
              req.onerror = () => reject(new Error('XHR failed for blob URL'))
              req.onload = () => resolve(req.response as ArrayBuffer)
              req.open('GET', url, true)
              req.send()
            })
            result = await new Promise((resolve, reject) => {
              loader.parse(buffer, '', resolve, (err: any) => reject(err))
            })
          } else {
            result = await withFetchContextFix(async () => new Promise((resolve, reject) => {
              loader.load(url, resolve, undefined, (err: any) => reject(err))
            }))
          }
          model = result.scene || (result.scenes && result.scenes[0]) || new Group()
          if (!model) throw new Error('GLTF loaded but no scene found')
        } catch (e:any) {
          console.error('ðŸŽ­ Sandbox: GLTF load failed:', e?.message || e)
          throw e
        }
      } else {
        throw new Error(`Unsupported file format: ${extension}`)
      }
      
      // Ignore stale loads
      if (myLoadId !== loadIdRef.current) {
        disposeObject3D(model)
        return
      }

      // Process model: normalize to consistent on-screen size regardless of source
      try {
        // Reset transform for accurate measurement
        model.position.set(0, 0, 0)
        model.rotation.set(0, 0, 0)
        model.scale.setScalar(1)
        ;(model as any).updateMatrixWorld?.(true)

        const preBox = new Box3().setFromObject(model)
        const preSphere = new Sphere()
        preBox.getBoundingSphere(preSphere)
        const currentRadius = Math.max(preSphere.radius || 0, 1e-6)
        // Target a consistent radius for all models
        const targetRadius = 1.0
        const normalizeScale = targetRadius / currentRadius
        model.scale.multiplyScalar(normalizeScale)
        ;(model as any).updateMatrixWorld?.(true)
        console.log('ðŸŽ­ Sandbox: Normalized model scale', { currentRadius, normalizeScale })
      } catch (e) {
        console.warn('ðŸŽ­ Sandbox: Normalization failed, using default scale', e)
      }
      
      // Enable shadows
      model.traverse((child) => {
        if (child instanceof Mesh) {
          child.castShadow = true
          child.receiveShadow = true
        }
      })
      
      // Tag model for reliable cleanup on next load
      ;(model as any).__SANDBOX_MODEL_ROOT__ = true
      scene.add(model)
      setCurrentRoot(model)
      frameObject(model)
      
      // Extract animations - Agent 3 Fix: Enhanced animation extraction
      const animations: AnimationClip[] = []
      let newMixer: AnimationMixer | null = null
      
      // Agent 3 Fix: More robust animation extraction
      if (model.animations && model.animations.length > 0) {
        newMixer = new AnimationMixer(model)
        animations.push(...model.animations)
        setMixer(newMixer)
        setCurrentAnimations(animations)
        applyDefaultAnimationSelection(animations)
        console.log('ðŸŽ­ Sandbox: Found animations:', animations.map(a => a.name))
        console.log('ðŸŽ­ Sandbox: Animation mixer created:', !!newMixer)
        } else {
        // Agent 3 Fix: Check for animations in child objects
        const allAnimations: AnimationClip[] = []
        model.traverse((child) => {
          if (child.animations && child.animations.length > 0) {
            allAnimations.push(...child.animations)
          }
        })
        
        if (allAnimations.length > 0) {
          // Attempt name-based retarget to the loaded model's skeleton
          try {
            const sourceBones: string[] = [] as any
            const targetBones: string[] = [] as any
            // Gather target bone names
            model.traverse((obj: any) => {
              if (obj && obj.isBone) targetBones.push(obj.name)
            })
            // Heuristic: infer source names from track node names
            const candidateClip = allAnimations[0]
            candidateClip.tracks.forEach(track => {
              const node = track.name.split('.')[0]
              if (node && !sourceBones.includes(node)) sourceBones.push(node)
            })
            const map = buildNameMapping(sourceBones, targetBones)
            const remapped = retargetClipsByName(allAnimations, map)
            newMixer = new AnimationMixer(model)
            animations.push(...(remapped.length > 0 ? remapped : allAnimations))
            console.log('ðŸŽ­ Sandbox: Retargeting map size:', Object.keys(map).length, 'remapped:', remapped.length)
          } catch (e) {
            console.warn('ðŸŽ­ Sandbox: Retargeting failed, using original clips', e)
            newMixer = new AnimationMixer(model)
            animations.push(...allAnimations)
          }
          setMixer(newMixer)
          setCurrentAnimations(animations)
          applyDefaultAnimationSelection(animations)
          console.log('ðŸŽ­ Sandbox: Found animations in child objects:', animations.map(a => a.name))
          console.log('ðŸŽ­ Sandbox: Animation mixer created from child animations:', !!newMixer)
        } else {
          // Check per-model procedural idle toggle
          const { currentModel, proceduralIdleSettings } = useAppStore.getState()
          const settings = (currentModel && proceduralIdleSettings[currentModel]) || { enabled: true }
          if (settings.enabled === false) {
            console.log('ðŸŽ­ Sandbox: No animations found and procedural idle disabled')
            newMixer = new AnimationMixer(model)
            setMixer(newMixer)
            setCurrentAnimations([])
          } else {
          // Try to load external animation library for Elmo
          try {
            const modelId = (currentModel || '').toLowerCase()
            const lib = (externalAnimationLibrary && externalAnimationLibrary[modelId]) || []
            if (lib.length > 0 && fbxLoader.current) {
              const loadedClips: AnimationClip[] = []
              for (const entry of lib) {
                try {
                  const src = await new Promise<Group>((resolve, reject) => {
                    fbxLoader.current!.load(entry.path, (g) => resolve(g), undefined, reject)
                  })
                  const srcClips = (src as any).animations || []
                  // Build mapping and retarget
                  const sourceBones: string[] = []
                  src.traverse((obj: any) => { if (obj && obj.isBone) sourceBones.push(obj.name) })
                  const targetBones: string[] = []
                  model.traverse((obj: any) => { if (obj && obj.isBone) targetBones.push(obj.name) })
                  const map = buildNameMapping(sourceBones, targetBones)
                  const remapped = retargetClipsByName(srcClips, map)
                  loadedClips.push(...(remapped.length > 0 ? remapped : srcClips))
                  console.log('ðŸŽ­ Sandbox: Loaded external animation:', entry.name, 'tracks:', remapped.length || srcClips.length)
                } catch (e) {
                  console.warn('ðŸŽ­ Sandbox: Failed to load external animation:', entry.path)
                }
              }
              if (loadedClips.length > 0) {
                newMixer = new AnimationMixer(model)
                animations.push(...loadedClips)
                setMixer(newMixer)
                setCurrentAnimations(animations)
                applyDefaultAnimationSelection(animations)
                console.log('ðŸŽ­ Sandbox: External library loaded with clips:', animations.map(a => a.name))
              } else {
                // Fallback to procedural idle if library empty
                console.log('ðŸŽ­ Sandbox: No external clips; generating procedural idle clip')
                const proceduralClip = createProceduralIdleClip(model)
                newMixer = new AnimationMixer(model)
                animations.push(proceduralClip)
                setMixer(newMixer)
                setCurrentAnimations(animations)
                applyDefaultAnimationSelection(animations)
              }
            } else {
              // Non-Elmo: use procedural idle
              console.log('ðŸŽ­ Sandbox: No animations; generating procedural idle clip')
              const proceduralClip = createProceduralIdleClip(model)
              newMixer = new AnimationMixer(model)
              animations.push(proceduralClip)
              setMixer(newMixer)
              setCurrentAnimations(animations)
              applyDefaultAnimationSelection(animations)
            }
            try {
              // selection applied above
            } catch {}
          } catch (e) {
            console.warn('ðŸŽ­ Sandbox: External animation load failed, using procedural idle', e)
            const proceduralClip = createProceduralIdleClip(model)
            newMixer = new AnimationMixer(model)
            animations.push(proceduralClip)
            setMixer(newMixer)
            setCurrentAnimations(animations)
            applyDefaultAnimationSelection(animations)
          }
          }
        }
      }
      
      console.log('ðŸŽ­ Sandbox: Model loaded successfully')
      onModelLoaded?.(model, animations, newMixer)
      
      // Ensure loading state is set to false after model loads
      const { setIsLoading } = useAppStore.getState()
      setIsLoading(false)
      
    } catch (error) {
      const message = (error && (error as any).message) || String(error)
      console.error('ðŸŽ­ Sandbox: Failed to load model:', message)
      // If load fails, keep scene as-is (no forced fallback)
    }
  }, [scene, frameObject, currentRoot, onModelLoaded])
  
  // Place markers function
  const placeMarkers = useCallback(() => {
    if (!currentRoot) return
    // Clear existing markers
    markers.forEach(marker => scene.remove(marker.mesh))
    setMarkers([])
    // Start guided placement
    const sequence = ['Hips', 'Chest', 'Head', 'LeftShoulder', 'LeftElbow', 'LeftWrist',
                      'RightShoulder', 'RightElbow', 'RightWrist', 'LeftKnee', 'LeftAnkle',
                      'RightKnee', 'RightAnkle']
    setGuidedLabels(sequence)
    setGuidedIndex(0)
    setPlacing(true)
    console.log('ðŸŽ­ Sandbox: Guided placement started. Place:', sequence[0])
  }, [currentRoot, scene, markers])

  // Guided placement click handling
  useEffect(() => {
    if (!placing || !currentRoot) return
    const canvas = gl.domElement
    const onPointerDown = (ev: MouseEvent) => {
      if (!raycasterRef.current) return
      const rect = canvas.getBoundingClientRect()
      const x = ((ev.clientX - rect.left) / rect.width) * 2 - 1
      const y = -((ev.clientY - rect.top) / rect.height) * 2 + 1
      pointerNdcRef.current.set(x, y)
      raycasterRef.current.setFromCamera(pointerNdcRef.current, camera as any)
      // Intersect with current model children
      const children: Object3D[] = []
      currentRoot.traverse(obj => { children.push(obj) })
      const hits = raycasterRef.current.intersectObjects(children, true)
      const hit = hits.find(h => (h.object as any).isMesh)
      const label = guidedLabels && guidedLabels[guidedIndex] ? guidedLabels[guidedIndex] : null
      if (!label) return
      // Match sandbox feel: marker radius scales with current model size (~2% of radius)
      const tmpBox = new Box3().setFromObject(currentRoot)
      const tmpSphere = new Sphere()
      tmpBox.getBoundingSphere(tmpSphere)
      const modelRadiusForMarkers = Math.max(tmpSphere.radius || 1, 1e-6)
      const markerRadius = Math.max(modelRadiusForMarkers * 0.02, 0.006)
      const markerMat = new MeshBasicMaterial({ color: 0xff5555, transparent: true, opacity: 0.85 }) as any
      markerMat.depthTest = false
      markerMat.depthWrite = false
      const marker = new Mesh(
        new SphereGeometry(markerRadius, 16, 16),
        markerMat
      )
      const pos = new Vector3()
      if (hit) {
        pos.copy(hit.point)
      } else {
        // Fallback: place in front of camera
        pos.set(0, 0, 0)
        currentRoot.localToWorld(pos)
      }
      marker.position.copy(pos)
      marker.name = label
      marker.frustumCulled = false
      marker.renderOrder = 999999
      scene.add(marker)
      setMarkers(prev => [...prev, { name: label, position: pos.clone(), mesh: marker }])
      const nextIndex = guidedIndex + 1
      if (guidedLabels && nextIndex >= guidedLabels.length) {
        setPlacing(false)
        console.log('ðŸŽ­ Sandbox: Markers complete')
      } else {
        setGuidedIndex(nextIndex)
        console.log('ðŸŽ­ Sandbox: Placed:', label, 'Next:', guidedLabels ? guidedLabels[nextIndex] : '')
      }
    }
    canvas.addEventListener('mousedown', onPointerDown)
    return () => canvas.removeEventListener('mousedown', onPointerDown)
  }, [placing, currentRoot, camera, gl, guidedLabels, guidedIndex, scene])

  // On-screen guided instruction overlay matching sandbox UX
  useEffect(() => {
    const currentLabel = guidedLabels && guidedLabels[guidedIndex]
    const ensureOverlay = () => {
      if (!guidedOverlayRef.current) {
        const el = document.createElement('div')
        el.style.position = 'fixed'
        el.style.top = '16px'
        el.style.left = '50%'
        el.style.transform = 'translateX(-50%)'
        el.style.background = 'rgba(0,0,0,0.6)'
        el.style.color = '#fff'
        el.style.padding = '8px 12px'
        el.style.borderRadius = '8px'
        el.style.fontSize = '14px'
        el.style.zIndex = '100000'
        el.style.pointerEvents = 'none'
        el.id = 'autorigger-guided-overlay'
        document.body.appendChild(el)
        guidedOverlayRef.current = el
      }
      return guidedOverlayRef.current
    }

    if (placing && currentLabel) {
      const el = ensureOverlay()
      if (el) el.textContent = `Place: ${currentLabel}`
    } else {
      // Remove overlay when not placing or sequence done
      if (guidedOverlayRef.current) {
        guidedOverlayRef.current.remove()
        guidedOverlayRef.current = null
      }
    }

    return () => {
      // Cleanup on unmount
      if (guidedOverlayRef.current && !placing) {
        guidedOverlayRef.current.remove()
        guidedOverlayRef.current = null
      }
    }
  }, [placing, guidedLabels, guidedIndex])

  // Clean up any existing overlays on mount and model changes
  useEffect(() => {
    // Remove any existing overlays when model changes
    const existingOverlay = document.getElementById('autorigger-guided-overlay')
    if (existingOverlay) {
      existingOverlay.remove()
    }
    
    // Reset placement state when model changes
    if (placing) {
      setPlacing(false)
      setGuidedLabels(null)
      setGuidedIndex(0)
    }
  }, [currentRoot, placing])
  
  // Build skeleton from markers
  const buildSkeletonFromMarkers = useCallback(() => {
    try {
      if (skeletonHelper) {
        scene.remove(skeletonHelper)
        setSkeletonHelper(null)
      }
      setSkeletonRoot(null)
      
      if (!currentRoot) {
        console.log('ðŸŽ­ Sandbox: No model to build skeleton for')
        return
      }
      const requiredLabels = ['Hips','Chest','Head','LeftShoulder','LeftElbow','LeftWrist','RightShoulder','RightElbow','RightWrist','LeftKnee','LeftAnkle','RightKnee','RightAnkle']
      const markersByName = markers.reduce((acc, m) => { acc[m.name] = m; return acc }, {} as Record<string, Marker>)
      const missing = requiredLabels.filter(l => !markersByName[l])
      if (missing.length > 0) {
        // Match sandbox: require full guided placement before building
        const el = document.getElementById('autorigger-guided-overlay') || (() => {
          const o = document.createElement('div');
          o.id = 'autorigger-guided-overlay';
          o.style.position = 'fixed';
          o.style.top = '16px';
          o.style.left = '50%';
          o.style.transform = 'translateX(-50%)';
          o.style.background = 'rgba(0,0,0,0.6)';
          o.style.color = '#fff';
          o.style.padding = '8px 12px';
          o.style.borderRadius = '8px';
          o.style.fontSize = '14px';
          o.style.zIndex = '100000';
          o.style.pointerEvents = 'none';
          document.body.appendChild(o); return o;
        })()
        el.textContent = `Place all markers first (${missing.length} remaining)`
        console.warn('ðŸŽ­ Sandbox: Missing markers:', missing)
        return
      }
      
      // Create bones based strictly on placed markers (no large defaults)
      const bones: Bone[] = []
      const makeBone = (name: string, pos: Vector3) => {
        const bone = new Bone()
        bone.name = name
        bone.position.copy(pos)
        bones.push(bone)
        return bone
      }
      
      
      const getLocal = (label: string) => {
        const m = markersByName[label]
        if (!m) return null
        const p = m.position.clone()
        return currentRoot ? currentRoot.worldToLocal(p) : p
      }
      
      // Compute local marker positions once
      const HipsL = getLocal('Hips') as Vector3
      const ChestL = getLocal('Chest') as Vector3
      const HeadL = getLocal('Head') as Vector3
      const LShoulderL = getLocal('LeftShoulder') as Vector3
      const LElbowL = getLocal('LeftElbow') as Vector3
      const LWristL = getLocal('LeftWrist') as Vector3
      const RShoulderL = getLocal('RightShoulder') as Vector3
      const RElbowL = getLocal('RightElbow') as Vector3
      const RWristL = getLocal('RightWrist') as Vector3
      const LKneeL = getLocal('LeftKnee') as Vector3
      const LAnkleL = getLocal('LeftAnkle') as Vector3
      const RKneeL = getLocal('RightKnee') as Vector3
      const RAnkleL = getLocal('RightAnkle') as Vector3

      // Helper for relative offsets
      const rel = (a: Vector3, b: Vector3) => new Vector3().subVectors(a, b)

      // Create bone hierarchy with positions relative to parent to avoid scale blow-up
      const root = makeBone('Hips', HipsL.clone())
      const spine = makeBone('Spine', rel(ChestL, HipsL))
      root.add(spine)
      const chest = makeBone('Chest', new Vector3(0, 0, 0))
      spine.add(chest)
      const head = makeBone('Head', rel(HeadL, ChestL))
      chest.add(head)

      // Arms (relative offsets)
      const lShoulder = makeBone('LeftShoulder', rel(LShoulderL, ChestL))
      chest.add(lShoulder)
      const lElbow = makeBone('LeftElbow', rel(LElbowL, LShoulderL))
      lShoulder.add(lElbow)
      const lWrist = makeBone('LeftWrist', rel(LWristL, LElbowL))
      lElbow.add(lWrist)

      const rShoulder = makeBone('RightShoulder', rel(RShoulderL, ChestL))
      chest.add(rShoulder)
      const rElbow = makeBone('RightElbow', rel(RElbowL, RShoulderL))
      rShoulder.add(rElbow)
      const rWrist = makeBone('RightWrist', rel(RWristL, RElbowL))
      rElbow.add(rWrist)

      // Legs (relative offsets)
      const lUpperLeg = makeBone('LeftUpperLeg', rel(LKneeL, HipsL))
      root.add(lUpperLeg)
      const lKnee = makeBone('LeftKnee', rel(LAnkleL, LKneeL))
      lUpperLeg.add(lKnee)
      const lAnkle = makeBone('LeftAnkle', new Vector3(0, 0, 0))
      lKnee.add(lAnkle)

      const rUpperLeg = makeBone('RightUpperLeg', rel(RKneeL, HipsL))
      root.add(rUpperLeg)
      const rKnee = makeBone('RightKnee', rel(RAnkleL, RKneeL))
      rUpperLeg.add(rKnee)
      const rAnkle = makeBone('RightAnkle', new Vector3(0, 0, 0))
      rKnee.add(rAnkle)
      
      // Match sandbox: ensure zero-length bones are slightly separated to avoid collapsed hierarchy
      for (let i = 0; i < bones.length; i++) {
        const b = bones[i]
        if (b.children && b.children.length > 0) {
          const child = b.children[0] as Bone
          if (child && child.position.length() < 1e-4) {
            child.position.y += 0.001
          }
        }
      }
      const skeleton = new Skeleton(bones)
      if (currentRoot) currentRoot.add(root)
      else scene.add(root)
      
      const helper = new SkeletonHelper(root)
      // Improve line definition/visibility across model colors
      const hmat = helper.material as any
      if (hmat) {
        hmat.depthTest = false
        hmat.depthWrite = false
        hmat.transparent = true
        hmat.opacity = 1.0
        hmat.toneMapped = false
        hmat.fog = false
        hmat.linewidth = 7
        if (hmat.color && typeof hmat.color.set === 'function') hmat.color.set(0x00ff88)
      }
      helper.frustumCulled = false
      helper.renderOrder = 999999
      helper.visible = isSkeletonVisible
      
      scene.add(helper)
      setSkeletonHelper(helper)
      setSkeletonRoot(root)
      setCurrentSkeleton(skeleton)
      
      console.log('ðŸŽ­ Sandbox: Skeleton generated')
      
    } catch (e) {
      console.error('ðŸŽ­ Sandbox: Skeleton generation failed:', e)
    }
  }, [currentRoot, markers, scene, skeletonHelper])
  
  // Auto weights binding
  const bindSkeletonToCurrentModel = useCallback(() => {
    try {
      if (!currentRoot || !currentSkeleton || !Array.isArray(currentSkeleton.bones) || currentSkeleton.bones.length === 0) {
        console.log('ðŸŽ­ Sandbox: bind skipped: missing model or skeleton')
        return
      }
      
      const bones = currentSkeleton.bones
      const boneWorld = bones.map(() => new Vector3())
      bones.forEach((b, i) => b.getWorldPosition(boneWorld[i]))
      
      const tmp = new Vector3()
      const parent = new Object3D()
      
      currentRoot.traverse((child) => {
        if (!(child && child instanceof Mesh && child.geometry)) return
        if (child instanceof SkinnedMesh) return
        
        const geom = child.geometry
        const pos = geom.attributes.position
        if (!pos) return
        
        const vcount = pos.count
        const skinIndex = new Uint16Array(vcount * 4)
        const skinWeight = new Float32Array(vcount * 4)
        const boneLocal = boneWorld.map((bw) => child.worldToLocal(bw.clone()))
        
        for (let i = 0; i < vcount; i++) {
          tmp.fromBufferAttribute(pos, i)
          
          // Find 4 nearest bones
          const nearest = []
          for (let bi = 0; bi < boneLocal.length; bi++) {
            const d = tmp.distanceToSquared(boneLocal[bi])
            nearest.push([bi, d])
          }
          nearest.sort((a, b) => a[1] - b[1])
          const pick = nearest.slice(0, 4)
          
          let wsum = 0
          const weights = pick.map(([, d]) => 1.0 / Math.max(1e-6, Math.sqrt(d)))
          for (const w of weights) wsum += w
          
          for (let k = 0; k < 4; k++) {
            const idx = i * 4 + k
            const bi = pick[k] ? pick[k][0] : 0
            const w = pick[k] ? (weights[k] / (wsum || 1)) : (k === 0 ? 1 : 0)
            skinIndex[idx] = bi
            skinWeight[idx] = w
          }
        }
        
        geom.setAttribute('skinIndex', new Uint16BufferAttribute(skinIndex, 4))
        geom.setAttribute('skinWeight', new Float32BufferAttribute(skinWeight, 4))
        
        const skinned = new SkinnedMesh(geom, child.material)
        skinned.name = child.name
        skinned.position.copy(child.position)
        skinned.quaternion.copy(child.quaternion)
        skinned.scale.copy(child.scale)
        skinned.castShadow = child.castShadow
        skinned.receiveShadow = child.receiveShadow
        
        // Replace in graph
        const p = child.parent || parent
        p.add(skinned)
        child.removeFromParent()
        
        try {
          skinned.bind(currentSkeleton)
          skinned.normalizeSkinWeights()
        } catch (_) {}
      })
      
      console.log('ðŸŽ­ Sandbox: Auto weights bound')
      
    } catch (e) {
      console.error('ðŸŽ­ Sandbox: bind failed:', e)
    }
  }, [currentRoot, currentSkeleton])
  
  // Save GLB function
  const saveGLB = useCallback(async () => {
    try {
      if (!currentRoot || !gltfExporter.current) {
        console.log('ðŸŽ­ Sandbox: No model to export')
        return
      }
      
      const result = await new Promise<any>((resolve) => {
        // Some GLTFExporter typings expect onError before options; pass undefined for onError
        gltfExporter.current!.parse(currentRoot, resolve, undefined as unknown as (e: ErrorEvent)=>void, { binary: true } as any)
      })
      
      // Create download link (handle ArrayBuffer vs JSON)
      let blob: Blob
      if (result && (result instanceof ArrayBuffer || ArrayBuffer.isView(result))) {
        const buffer = result instanceof ArrayBuffer ? new Uint8Array(result) : new Uint8Array(result.buffer)
        blob = new Blob([buffer], { type: 'model/gltf-binary' })
      } else if (typeof result === 'object') {
        blob = new Blob([JSON.stringify(result)], { type: 'model/gltf+json' })
      } else {
        blob = new Blob([String(result)], { type: 'application/octet-stream' })
      }
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = (blob.type === 'model/gltf-binary') ? 'exported_model.glb' : 'exported_model.gltf'
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      URL.revokeObjectURL(url)
      
      console.log('ðŸŽ­ Sandbox: GLB exported successfully')
      
    } catch (error) {
      console.error('ðŸŽ­ Sandbox: GLB export failed:', error)
    }
  }, [currentRoot, gltfExporter])
  
  // Clear function
  const clear = useCallback(() => {
    if (currentRoot) {
      scene.remove(currentRoot)
      setCurrentRoot(null)
    }
    
    markers.forEach(marker => scene.remove(marker.mesh))
    setMarkers([])
    
    if (skeletonHelper) {
      scene.remove(skeletonHelper)
      setSkeletonHelper(null)
    }
    
    setSkeletonRoot(null)
    setCurrentSkeleton(null)
    setMixer(null)
    setCurrentAnimations([])
    
    console.log('ðŸŽ­ Sandbox: Scene cleared')
  }, [currentRoot, scene, markers, skeletonHelper])

  const setSkeletonVisible = useCallback((visible: boolean) => {
    setIsSkeletonVisible(visible)
    if (skeletonHelper) skeletonHelper.visible = visible
    // Toggle all marker meshes to match skeleton visibility
    try {
      markers.forEach(m => { if (m?.mesh) m.mesh.visible = visible })
    } catch {}
  }, [skeletonHelper, markers])

  const toggleSkeletonVisible = useCallback(() => {
    const next = !isSkeletonVisible
    setIsSkeletonVisible(next)
    if (skeletonHelper) skeletonHelper.visible = next
    try {
      markers.forEach(m => { if (m?.mesh) m.mesh.visible = next })
    } catch {}
  }, [isSkeletonVisible, skeletonHelper, markers])
  
  // Animation frame update - Agent 3 Fix: Enhanced mixer update with debugging
  useFrame((_, delta) => {
    if (mixer) {
      const deltaClamped = Math.min(delta, 1 / 30) // clamp to avoid big jumps on low FPS
      mixer.update(deltaClamped)
      // Agent 3 Fix: Add periodic debugging for mixer updates
      if (Math.random() < 0.001) { // Log very occasionally to avoid spam
        console.log('ðŸŽ­ Sandbox: Mixer update - delta:', deltaClamped.toFixed(4), 'time:', mixer.time.toFixed(2))
      }
    }
  })
  
  // Load default model on mount exactly once, only if no model/upload is selected
  const didLoadDefaultRef = useRef(false)
  useEffect(() => {
    if (didLoadDefaultRef.current) return
    const { currentUploadedModel: up, currentModel: cm, setCurrentModel } = useAppStore.getState()
    if (up?.url) return
    if (cm) return
    didLoadDefaultRef.current = true
    // Route default through store to avoid double-load
    try { setCurrentModel('elmo') } catch {}
  }, [])

  // Ensure loading state is properly managed
  useEffect(() => {
    // Set loading to false when component mounts and model is loaded
    const { setIsLoading } = useAppStore.getState()
    if (currentRoot) {
      setIsLoading(false)
    }
    
    // Fallback: ensure loading is set to false after a timeout
    const timeout = setTimeout(() => {
      setIsLoading(false)
    }, 5000) // 5 second timeout
    
    return () => clearTimeout(timeout)
  }, [currentRoot])

  // Respond to uploaded model selection from store (mirror sandbox page behavior)
  useEffect(() => {
    if (currentUploadedModel && currentUploadedModel.url) {
      console.log('ðŸŽ­ Sandbox: Loading uploaded blob:', currentUploadedModel.name)
      loadModel(currentUploadedModel.url, currentUploadedModel.name)
    }
  }, [currentUploadedModel?.url, currentUploadedModel?.name, loadModel])

  // Respond to character selection from store (Agent 2 character switching)
  useEffect(() => {
    if (currentModel && !currentUploadedModel) {
      console.log('ðŸŽ­ Sandbox: Loading character model:', currentModel)

      // Merge legacy presets and manifest characters (if available) like LeftPanel
      const legacyPresets = [
        { id: 'default_fbx', name: 'Default FBX (Animated)', category: 'Sample', thumbnail: null, modelPath: '/models/Default_Model.fbx' },
        { id: 'elmo', name: 'Elmo (Stuffed Animal)', category: 'Fantasy', thumbnail: null, modelPath: '/Default_Characters/elmo_rigged.glb' },
        { id: 'spiderman_chasm', name: 'Spider-Man Chasm', category: 'Superhero', thumbnail: null, modelPath: '/Default_Characters/mr_spiderman_chasm.glb' },
        { id: 'spiderman_suit', name: 'Spider-Man Suit', category: 'Superhero', thumbnail: null, modelPath: '/Default_Characters/New_spiderman_suit_we_0613175722_texture.fbx' },
        { id: 'spiderman', name: 'Spider-Man', category: 'Superhero', thumbnail: null, modelPath: '/Default_Characters/Spider-Man.fbx' },
        { id: 'spiderman_ps4', name: 'Spider-Man PS4', category: 'Superhero', thumbnail: null, modelPath: '/Default_Characters/SPIDERMAN PS4.fbx' },
        { id: 'spiderham', name: 'Spider-Ham', category: 'Superhero', thumbnail: null, modelPath: '/Default_Characters/uploads_files_4424020_SpiderHam_Current_LW.fbx' },
        { id: 'crz9_fortnite', name: 'CRZ_9 Fortnite (Idle)', category: 'Sample', thumbnail: null, modelPath: '/Default_Characters/CRZ_9_Fortnite/cyberpunk_idle.glb' },
      ]
      const manifestChars: any[] = (useAppStore.getState() as any).characters || []
      const all = new Map(legacyPresets.map(c => [c.id, c]))
      for (const c of manifestChars) if (!all.has(c.id)) all.set(c.id, c)
      const allCharacters = Array.from(all.values())

      const selectedChar = allCharacters.find(char => char.id === currentModel)
      if (selectedChar) {
        console.log('ðŸŽ­ Sandbox: Loading character:', selectedChar.name, 'from path:', selectedChar.modelPath)
        loadModel(selectedChar.modelPath)
      } else {
        console.warn('ðŸŽ­ Sandbox: Character not found:', currentModel)
      }
    }
  }, [currentModel, currentUploadedModel, loadModel])

  // Debug animation status
  useEffect(() => {
    console.log('ðŸŽ­ Sandbox: Animation status - mixer:', !!mixer, 'animations:', currentAnimations.length, 'names:', currentAnimations.map(a => a.name))
  }, [mixer, currentAnimations])

  // Cleanup overlays on unmount
  useEffect(() => {
    return () => {
      // Remove any overlays when component unmounts
      const existingOverlay = document.getElementById('autorigger-guided-overlay')
      if (existingOverlay) {
        existingOverlay.remove()
      }
    }
  }, [])
  
  // Expose functions to parent component
  useEffect(() => {
    if (typeof window !== 'undefined') {
      (window as any).sandboxModelViewer = {
        loadModel,
        placeMarkers,
        buildSkeletonFromMarkers,
        bindSkeletonToCurrentModel,
        saveGLB,
        clear,
        setSkeletonVisible,
        toggleSkeletonVisible,
        // Agent 3: test helper to select a character by id via store
        selectCharacter: (id: string) => {
          try {
            const { setCurrentModel } = useAppStore.getState()
            setCurrentModel(id)
            return true
          } catch {
            return false
          }
        },
        // Agent 3: force-load a character by id (clear then load)
        loadCharacterById: (id: string) => {
          try {
            const mapping = [
              { id: 'default_fbx', name: 'Default FBX (Animated)', modelPath: '/models/Default_Model.fbx' },
              { id: 'elmo', name: 'Elmo (Stuffed Animal)', modelPath: '/Default_Characters/elmo_rigged.glb' },
              { id: 'spiderman_chasm', name: 'Spider-Man Chasm', modelPath: '/Default_Characters/mr_spiderman_chasm.glb' },
              { id: 'spiderman_suit', name: 'Spider-Man Suit', modelPath: '/Default_Characters/New_spiderman_suit_we_0613175722_texture.fbx' },
              { id: 'spiderman', name: 'Spider-Man', modelPath: '/Default_Characters/Spider-Man.fbx' },
              { id: 'spiderman_ps4', name: 'Spider-Man PS4', modelPath: '/Default_Characters/SPIDERMAN PS4.fbx' },
              { id: 'spiderham', name: 'Spider-Ham', modelPath: '/Default_Characters/uploads_files_4424020_SpiderHam_Current_LW.fbx' },
              { id: 'crz9_fortnite', name: 'CRZ_9 Fortnite (Idle)', modelPath: '/Default_Characters/CRZ_9_Fortnite/cyberpunk_idle.glb' },
            ]
            const selected = mapping.find(m => m.id === id)
            if (!selected) return false
            try { clear() } catch {}
            setTimeout(() => loadModel(selected.modelPath), 0)
            return true
          } catch {
            return false
          }
        },
        // Agent 3: expose current animation names for diagnostics/tests
        getAnimations: () => {
          try {
            return (currentAnimations || []).map(a => a.name)
          } catch {
            return []
          }
        }
      }
    }
  }, [loadModel, placeMarkers, buildSkeletonFromMarkers, bindSkeletonToCurrentModel, saveGLB, clear, setSkeletonVisible, toggleSkeletonVisible, currentAnimations])
  
  // Get current model name for facial rig selection
  const currentModelName = currentRoot?.name || 'unknown'
  
  // Facial rig configurations for different models
  const getFacialRigForModel = (modelName: string): FacialRig => {
    // Elmo-specific configuration for his unique beak-like mouth
    if (modelName.toLowerCase().includes('elmo') || modelName.toLowerCase().includes('sketchfab_scene')) {
      return {
        jawBone: 'jaw',
        upperLipBlendShape: 'mouthOpen',
        lowerLipBlendShape: 'mouthOpen', // Elmo's mouth opens as one unit
        mouthCornerBlendShapes: ['mouthWidth'],
        tongueBlendShapes: ['tongue'],
        jawRotationAxis: 'x',
        maxJawRotation: 0.8, // More pronounced jaw movement for Elmo
        lipShapeMultiplier: 1.5 // Amplify mouth movements for Elmo's expressive face
      }
    }
    
    // Default configuration for other models
    return {
      jawBone: 'jaw',
      upperLipBlendShape: 'mouthOpen',
      lowerLipBlendShape: 'lipCompression',
      mouthCornerBlendShapes: ['mouthWidth'],
      tongueBlendShapes: ['tongue'],
      jawRotationAxis: 'x',
      maxJawRotation: 0.5,
      lipShapeMultiplier: 1.0
    }
  }
  
  const facialRig = getFacialRigForModel(currentModelName)

  return (
    <group ref={groupRef}>
      {/* Model and markers are added directly to scene */}
      
      {/* Animation Controller - Phase 4 Priority 1 */}
      {mixer && currentAnimations.length > 0 ? (
        <AnimationController
          mixer={mixer}
          animations={currentAnimations}
          config={{
            enableAI: true,
            enableAutoTransitions: true,
            enableGestureOverlay: true,
            enableEmotionSystem: true,
            transitionDuration: 0.3,
            aiUpdateInterval: 1000,
            performanceOptimization: true
          }}
        />
      ) : null}

      {/* Lip Sync Component - Phase 4 Priority 2 */}
      {currentRoot && (
        <LipSync
          modelRef={{ current: currentRoot }}
          facialRig={facialRig}
          enabled={lipSyncEnabled}
          onLipSyncEvent={(event) => {
            console.log('ðŸŽ­ Agent 4 - Lip sync event:', event)
          }}
          onPerformanceUpdate={(metrics) => {
            console.log('ðŸŽ­ Agent 4 - Performance metrics:', metrics)
          }}
        />
      )}
    </group>
  )
}
